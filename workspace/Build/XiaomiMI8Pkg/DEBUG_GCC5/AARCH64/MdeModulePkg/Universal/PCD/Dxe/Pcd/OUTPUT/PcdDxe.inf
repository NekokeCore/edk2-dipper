## @file
# PCD DXE driver manage database contains all dynamic PCD entries and produce the implementation of PCD protocol.
#
# This version PCD DXE depends on the external PCD database binary file, not built in PCD data base.
# There are two PCD Protocols as follows:
#   1) PCD_PROTOCOL
#      It is EDKII implementation which support Dynamic/DynamicEx type Pcds.
#   2) EFI_PCD_PROTOCOL
#      It is defined by PI specification 1.2, Vol 3 which only support dynamicEx
#      type Pcd.
#
# For dynamicEx type PCD, it is compatible between PCD_PROTOCOL and EFI_PCD_PROTOCOL.
# PCD DXE driver will produce above two protocols at same time.
#
# PCD database is generated as the separate binary image at build time. The binary image
# will be intergrated into Firmware volume together with PCD driver.
#
# ########################################
# #                                                                            #
# #                      Introduction of PCD database                          #
# #                                                                            #
# ########################################
#
# 1, Introduction
#    PCD database hold all dynamic type PCD information. The structure of PEI PCD
#    database is generated by build tools according to dynamic PCD usage for
#    specified platform.
#
# 2, Dynamic Type PCD
#    Dynamic type PCD is used for the configuration/setting which value is determined
#    dynamic. In contrast, the value of static type PCD (FeatureFlag, FixedPcd,
#    PatchablePcd) is fixed in final generated FD image in build time.
#
#    2.1 The "dynamic" determination means one of below cases:
#      a) The PCD setting value is produced by someone driver and consumed by
#         other driver in execution time.
#      b) The PCD setting value is set/get by user from FrontPage.
#      c) The PCD setting value is produced by platform OEM vendor in specified area.
#
#    2.2 According to module distribution way, dynamic PCD could be classfied as:
#      a) Dynamic:
#         If module is released in source code and will be built with platform
#         DSC, the dynamic PCD used by this module can be accessed as:
#                 PcdGetxx(PcdSampleDynamicPcd);
#         In building platform, build tools will translate PcdSampleDynamicPcd to
#         pair of {Token Space Guid: Token Number} for this PCD.
#      b) DynamicEx:
#         If module is release as binary and will not pariticpate platform building,
#         the dynamic PCD used by this module need be accessed as:
#               PcdGetxxEx(gEfiMyTokenspaceGuid, PcdSampleDynamicPcd)
#         Developer need explicity gives {Token Space Guid:Token Number} as parameter
#         in writting source code.
#
#    2.3 According to PCD value's storage method, dynamic PCD could be classfied as:
#      a) Default Storage:
#         - The PCD value is stored in PCD database maintained by PCD driver in boot
#           time memory.
#         - This type is used for communication between PEIM/DXE driver, DXE/DXE
#           driver. But all set/get value will be losted after boot-time memory
#           is turn off.
#         - [PcdsDynamicDefault] is used as section name for this type PCD in
#           platform DSC file. [PcdsDynamicExDefault] is used for dynamicEx type PCD.
#
#      b) Variable Storage:
#         - The PCD value is stored in variable area.
#         - As default storage type, this type PCD could be used for PEI/DXE driver
#           communication. But beside it, this type PCD could also be used to store
#           the value associate with a HII setting via variable interface.
#         - In PEI phase, the PCD value could only be got but can not be set due
#           to variable area is readonly.
#         - [PcdsDynamicHii] is used as section name for this type PCD in platform
#           DSC file. [PcdsDynamicExHii] is for dynamicEx type PCD.
#
#      c) OEM specificed storage area:
#         - The PCD value is stored in OEM specified area which base address is
#           specified by PCD setting - PcdVpdBaseAddress64 or PcdVpdBaseAddress.
#         - The area is read only for PEI and DXE phase.
#         - [PcdsDynamicVpd] is used as section name for this type PCD in platform
#           DSC file. [PcdsDynamicExVpd] is for dynamicex type PCD.
#
#    2.4 When and how to use dynamic PCD
#      Module developer do not care the used PCD is dynamic or static when writting
#      source code/INF. Dynamic PCD and dynamic type is pointed by platform integrator
#      in platform DSC file. Please ref section 2.3 to get matching between dynamic
#      PCD type and section name in DSC file.
#
# 3, PCD database:
#    Although dynamic PCD could be in different storage type as above description,
#    but the basic information and default value for all dynamic PCD is hold
#    by PCD database maintained by PEI/DXE driver.
#
#    As the whole EFI BIOS boot path is divided into PEI/DXE phase, the PCD database
#    also is divided into Pei/Dxe database maintaied by PcdPeim/PcdDxe driver separatly.
#    To make PcdPeim's driver image smaller, PEI PCD database only hold all dynamic
#    PCD information used in PEI phase or use in both PEI/DXE phase. And DXE PCD
#    database contains all PCDs used in PEI/DXE phase in memory.
#
#    Build tool will generate PCD database into the separate binary file for
#    PEI/DXE PCD driver according to dynamic PCD section in platform DSC file.
#
#    3.1 PcdPeim and PcdDxe
#      PEI PCD database is maintained by PcdPeim driver run from flash. PcdPeim driver
#      build guid hob in temporary memory and copy the binary data base from flash
#      to temporary memory for PEI PCD database.
#      DXE PCD database is maintained by PcdDxe driver.At entry point of PcdDxe driver,
#      a new PCD database is allocated in boot-time memory which including all
#      PEI PCD and DXE PCD entry.
#
#      Pcd driver should run as early as possible before any other driver access
#      dynamic PCD's value. PEI/DXE "Apriori File" mechanism make it possible by
#      making PcdPeim/PcdDxe as first dispatching driver in PEI/DXE phase.
#
#    3.2 Token space Guid/Token number, Platform token, Local token number
#           Dynamic PCD
#          +-----------+               +---------+
#          |TokenSpace |               |Platform |
#          |   Guid    |  build tool   | Token   |
#          |    +      +-------------->| Number  |
#          |  Token    |               +---------+`._
#          |  Number   |                             `.
#          +-----------+                               `.  +------+
#                                                        `-|Local |
#                                                          |Token |
#                               DynamicEx PCD            ,-|Number|
#                               +-----------+         ,-'  +------+
#                               |TokenSpace |      ,-'
#                               |   Guid    |  _,-'
#                               |    +      +.'
#                               |  Token    |
#                               |  Number   |
#                               +-----------+
#
#
#      3.2.1 Pair of Token space guid + Token number
#        Any type PCD is identified by pair of "TokenSpaceGuid + TokeNumber". But it
#        is not easy maintained by PCD driver, and hashed token number will make
#        searching slowly.
#
#      3.2.2 Platform Token Number
#        "Platform token number" concept is introduced for mapping to a pair of
#        "TokenSpaceGuid + TokenNumber". The platform token number is generated by
#        build tool in autogen.h and all of them are continual in a platform scope
#        started from 1.(0 meaning invalid internal token number)
#        With auto-generated "platform token number", PcdGet(PcdSampleDynamicPcd)
#        in source code is translated to LibPcdGet(_PCD_TOKEN_PcdSampleDynamicPcd)
#        in autogen.h.
#        Notes: The mapping between pair of "tokenspace guid + token number" and
#        "internal token number" need build tool establish, so "platform token number"
#        mechanism is not suitable for binary module which use DynamicEx type PCD.
#        To access a dynamicEx type PCD, pair of "token space guid/token number" all need
#        to be specificed for PcdSet/PcdGet accessing macro.
#
#        Platform Token Number is started from 1, and inceased continuous. From whole
#        platform scope, there are two zones: PEI Zone and DXE Zone
#                  |                      Platform Token Number
#        ----------|----------------------------------------------------------------
#        PEI Zone: |            1                 ~  PEI_LOCAL_TOKEN_NUMBER
#        DXE Zone: | (PEI_LOCAL_TOKEN_NUMBER + 1) ~ (PEI_LOCAL_TOKEN_NUMBER + DXE_LOCAL_TOKEN_NUMBER)
#
#      3.2.3 Local Token Number
#        To fast searching a PCD entry in PCD database, PCD driver translate
#        platform token number to local token number via a mapping table.
#        For binary DynamicEx type PCD, there is a another mapping table to translate
#        "token space guid + token number" to local token number directly.
#        Local token number is identifier for all internal interface in PCD PEI/DXE
#        driver.
#
#        A local token number is a 32-bit value in following meaning:
#         32 ------------- 28 ---------- 24 -------- 0
#          | PCD type mask  | Datum Type  |  Offset  |
#          +-----------------------------------------+
#        where:
#          PCd type mask: indicate Pcd type from following macro:
#                         PCD_TYPE_DATA
#                         PCD_TYPE_HII
#                         PCD_TYPE_VPD
#                         PCD_TYPE_STRING
#          Datum Type   : indicate PCD vaue type from following macro:
#                         PCD_DATUM_TYPE_POINTER
#                         PCD_DATUM_TYPE_UINT8
#                         PCD_DATUM_TYPE_UINT16
#                         PCD_DATUM_TYPE_UINT32
#                         PCD_DATUM_TYPE_UINT64
#          Offset      : indicate the related offset of PCD value in PCD database array.
#       Based on local token number, PCD driver could fast determine PCD type, value
#       type and get PCD entry from PCD database.
#
#    3.3 PCD Database binary file
#      PCD Database binary file will be created at build time as the standalone binary image.
#      To understand the binary image layout, PCD Database C structure is still generated
#      as comments by build tools in PCD driver's autogen.h/
#      autogen.c file. In generated C structure, following information is stored:
#      - ExMapTable: This table is used translate a binary dynamicex type PCD's
#                    "tokenguid + token" to local token number.
#      - LocalTokenNumberTable:
#                    This table stores all local token number in array, use "Internal
#                    token number" as array index to get PCD entry's offset fastly.
#      - SizeTable:  This table stores the size information for all PCD entry.
#      - GuidTable:  This table stores guid value for DynamicEx's token space,
#                    HII type PCD's variable GUID.
#      - SkuIdTable: TBD
#      - SystemSkuId: TBD
#      - PCD value structure:
#                    Every PCD has a value record in PCD database. For different
#                    datum type PCD has different record structure which will be
#                    introduced in 3.3.1
#
#      In a PCD database structure, there are two major area: Init and UnInit.
#      Init area is use stored above PCD internal structure such as ExMapTable,
#      LocalTokenNumberTable etc and the (default) value of PCD which has default
#      value specified in platform DSC file.
#      Unint area is used stored the value of PCD which has no default value in
#      platform DSC file, the value of NULL, 0 specified in platform DSC file can
#      be seemed as "no default value".
#
#      3.3.1 Simple Sample PCD Database C Structure
#        A general sample of PCD database structue is as follows:
#        typedef struct _PCD_DATABASE {
#          typedef struct _PCD_DATABASE_INIT {
#            #===== Following is PCD database internal maintain structures
#            DYNAMICEX_MAPPING ExMapTable[PEI_EXMAPPING_TABLE_SIZE];
#            UINT32            LocalTokenNumberTable[PEI_LOCAL_TOKEN_NUMBER_TABLE_SIZE];
#            GUID              GuidTable[PEI_GUID_TABLE_SIZE];
#            SIZE_INFO         SizeTable[PEI_SIZE_TABLE_SIZE];
#            UINT8             SkuIdTable[PEI_SKUID_TABLE_SIZE];
#            SKU_ID            SystemSkuId;
#
#            #===== Following is value structure for PCD with default value
#            ....
#            ....
#            ....
#          } Init;
#          typedef struct _PCD_DATABSE_UNINIT {
#            #==== Following is value structure for PCD without default value
#            ....
#            ....
#          } UnInit;
#        }
#
#      3.3.2 PCD value structure in PCD database C structure
#        The value's structure is generated by build tool in PCD database C structure.
#        The PCDs in different datum type has different value structure.
#
#        3.3.2.1 UINT8/UINT16/UINT32/UINT64 datum type PCD
#          The C structure for these datum type PCD is just a UINT8/UINT16/UINT32/UINT64
#          data member in PCD database, For example:
#          UINT16  PcdHardwareErrorRecordLevel_d3705011_bc19_4af7_be16_f68030378c15_VariableDefault_0;
#          Above structure is generated by build tool, the member name is "PcdCName_Guidvalue"
#          Member type is UINT16 according to PcdHardwareErrorRecordLevel declaration
#          in DEC file.
#
#        3.3.2.2 VOID* datum type PCD
#          The value of VOID* datum type PCD is a UINT8/UINT16 array in PCD database.
#
#          3.3.2.2.1 VOID* - string type
#            If the default value for VOID* datum type PCD like L"xxx", the PCD is
#            used for unicode string, and C structure of this datum type PCD is
#            UINT16 string array in PCD database, for example:
#            UINT16 StringTable[29];
#            The number of 29 in above sample is max size of a unicode string.
#
#            If the default value for VOID* datum type PCD like "xxx", the PCD is
#            used for ascii string, and C structure of this datum type PCD is
#            UINT8 string array in PCD database, for example:
#            UINT8 StringTable[20];
#            The number of 20 in above sample is max size of a ascii string.
#
#          3.3.2.2.2 VOID* - byte array
#            If the default value of VOID* datum type PCD like {'0x29', '0x01', '0xf2'}
#            the PCD is used for byte array. The generated structrue is same as
#            above ascii string table,
#            UINT8 StringTable[13];
#            The number of 13 in above sample is max size of byte array.
#
#      3.3.3 Some utility structures in PCD Database
#        3.3.3.1 GuidTable
#          GuidTable array is used to store all related GUID value in PCD database:
#            - Variable GUID for HII type PCD
#            - Token space GUID for dynamicex type PCD
#
#  Copyright (c) 2006 - 2018, Intel Corporation. All rights reserved.<BR>
#
#  SPDX-License-Identifier: BSD-2-Clause-Patent
#
#
##

# DO NOT EDIT
# FILE auto-generated

[Defines]
  INF_VERSION                = 0x00010017
  BASE_NAME                  = PcdDxe
  FILE_GUID                  = 80CF7257-87AB-47f9-A3FE-D50B76D89541
  MODULE_TYPE                = DXE_DRIVER
  VERSION_STRING             = 4.0
  PCD_IS_DRIVER              = DXE_PCD_DRIVER
  ENTRY_POINT                = PcdDxeInit
  MODULE_UNI_FILE            = PcdDxe.uni

[Packages.AARCH64]
  MdePkg/MdePkg.dec
  MdeModulePkg/MdeModulePkg.dec

[Binaries.AARCH64]
  PE32|PcdDxe.efi
  DXE_DEPEX|PcdDxe.depex

[PatchPcd.AARCH64]

[Protocols.AARCH64]
  ## SOMETIMES_CONSUMES
  ## PRODUCES
  gPcdProtocolGuid

  ## CONSUMES
  ## PRODUCES
  gEfiPcdProtocolGuid

  ## SOMETIMES_CONSUMES
  ## SOMETIMES_PRODUCES
  gGetPcdInfoProtocolGuid

  ## SOMETIMES_CONSUMES
  ## SOMETIMES_PRODUCES
  gEfiGetPcdInfoProtocolGuid

  ## NOTIFY
  ## SOMETIMES_CONSUMES
  gEdkiiVariableLockProtocolGuid

  ## SOMETIMES_CONSUMES
  gEfiDevicePathProtocolGuid

  ## UNDEFINED
  gEfiDebugPortProtocolGuid

  ## SOMETIMES_PRODUCES
  gEfiDriverBindingProtocolGuid

  ## SOMETIMES_CONSUMES
  gEfiSimpleTextOutProtocolGuid

  ## SOMETIMES_CONSUMES
  gEfiGraphicsOutputProtocolGuid

  ## SOMETIMES_CONSUMES
  gEfiHiiFontProtocolGuid

  ## SOMETIMES_CONSUMES
  ## SOMETIMES_CONSUMES
  gEfiSimpleFileSystemProtocolGuid

  ## SOMETIMES_CONSUMES # Consumes if gEfiGraphicsOutputProtocolGuid uninstalled
  gEfiUgaDrawProtocolGuid

  ## SOMETIMES_PRODUCES # User chooses to produce it
  gEfiComponentNameProtocolGuid

  ## SOMETIMES_PRODUCES # User chooses to produce it
  gEfiComponentName2ProtocolGuid

  ## SOMETIMES_PRODUCES # User chooses to produce it
  gEfiDriverConfigurationProtocolGuid

  ## SOMETIMES_PRODUCES # User chooses to produce it
  gEfiDriverConfiguration2ProtocolGuid

  ## SOMETIMES_PRODUCES # User chooses to produce it
  gEfiDriverDiagnosticsProtocolGuid

  ## SOMETIMES_PRODUCES # User chooses to produce it
  gEfiDriverDiagnostics2ProtocolGuid

  ## SOMETIMES_CONSUMES
  ## SOMETIMES_CONSUMES
  gEfiLoadedImageProtocolGuid

  ## SOMETIMES_CONSUMES
  gEfiFirmwareVolume2ProtocolGuid

  ## SOMETIMES_CONSUMES
  gEfiLoadFileProtocolGuid

  ## SOMETIMES_CONSUMES
  gEfiLoadFile2ProtocolGuid


[Ppis.AARCH64]

[Guids.AARCH64]
  ## SOMETIMES_CONSUMES  ## HOB
  gPcdDataBaseHobGuid

  ## CONSUMES  ## GUID  # PCD database signature GUID.
  gPcdDataBaseSignatureGuid

  ## SOMETIMES_CONSUMES  ## GUID
  gEfiMdeModulePkgTokenSpaceGuid

  ## SOMETIMES_CONSUMES  ## GUID
  gEfiVTUTF8Guid

  ## SOMETIMES_CONSUMES  ## GUID
  gEfiVT100Guid

  ## SOMETIMES_CONSUMES  ## GUID
  gEfiVT100PlusGuid

  ## SOMETIMES_CONSUMES  ## GUID
  gEfiPcAnsiGuid

  ## SOMETIMES_CONSUMES  ## GUID
  gEfiUartDevicePathGuid

  ## SOMETIMES_CONSUMES  ## GUID
  gEfiSasDevicePathGuid

  ## SOMETIMES_CONSUMES  ## GUID
  gEfiVirtualDiskGuid

  ## SOMETIMES_CONSUMES  ## GUID
  gEfiVirtualCdGuid

  ## SOMETIMES_CONSUMES  ## GUID
  gEfiPersistentVirtualDiskGuid

  ## SOMETIMES_CONSUMES  ## GUID
  gEfiPersistentVirtualCdGuid

  ## SOMETIMES_CONSUMES  ## Event
  gEfiEventReadyToBootGuid

  ## SOMETIMES_CONSUMES  ## Event
  gEfiEventLegacyBootGuid

  ## SOMETIMES_CONSUMES  ## Variable
  gEfiGlobalVariableGuid

  ## SOMETIMES_CONSUMES  ## SystemTable
  gEfiAcpi20TableGuid

  ## SOMETIMES_CONSUMES  ## SystemTable
  gEfiAcpi10TableGuid

  ## CONSUMES  ## SystemTable
  gEfiHobListGuid

  ## SOMETIMES_CONSUMES ## UNDEFINED
  gEfiFileInfoGuid


[PcdEx.AARCH64]
  ## SOMETIMES_CONSUMES
  gEfiMdeModulePkgTokenSpaceGuid.PcdVpdBaseAddress64

  ## SOMETIMES_CONSUMES
  gEfiMdeModulePkgTokenSpaceGuid.PcdSetNvStoreDefaultId


[LibraryClasses.AARCH64]
## @LIB_INSTANCES
#  MdePkg/Library/DxePcdLib/DxePcdLib.inf
#  MdePkg/Library/BaseLib/BaseLib.inf
#  MdePkg/Library/BaseMemoryLibOptDxe/BaseMemoryLibOptDxe.inf
#  ArmPkg/Library/ArmLib/ArmBaseLib.inf
#  ArmPkg/Library/ArmCacheMaintenanceLib/ArmCacheMaintenanceLib.inf
#  MdePkg/Library/BaseIoLibIntrinsic/BaseIoLibIntrinsic.inf
#  ArmPkg/Library/CompilerIntrinsicsLib/CompilerIntrinsicsLib.inf
#  MdePkg/Library/BaseDebugPrintErrorLevelLib/BaseDebugPrintErrorLevelLib.inf
#  XiaomiMI8Pkg/Library/FrameBufferSerialPortLib/FrameBufferSerialPortLib.inf
#  MdePkg/Library/BasePrintLib/BasePrintLib.inf
#  MdePkg/Library/BaseDebugLibSerialPort/BaseDebugLibSerialPort.inf
#  MdePkg/Library/UefiMemoryAllocationLib/UefiMemoryAllocationLib.inf
#  MdePkg/Library/UefiDevicePathLib/UefiDevicePathLib.inf
#  MdePkg/Library/UefiBootServicesTableLib/UefiBootServicesTableLib.inf
#  MdePkg/Library/UefiRuntimeServicesTableLib/UefiRuntimeServicesTableLib.inf
#  MdePkg/Library/UefiLib/UefiLib.inf
#  MdePkg/Library/DxeHobLib/DxeHobLib.inf
#  MdePkg/Library/UefiDriverEntryPoint/UefiDriverEntryPoint.inf
#  MdePkg/Library/DxeServicesLib/DxeServicesLib.inf
#  MdePkg/Library/BaseStackCheckLib/BaseStackCheckLib.inf

[Depex.AARCH64]
#  (TRUE) AND (gEfiPcdProtocolGuid) AND (gEfiPcdProtocolGuid) AND (gEfiPcdProtocolGuid) AND (gEfiPcdProtocolGuid) AND (gEfiBdsArchProtocolGuid AND gEfiCpuArchProtocolGuid AND gEfiMetronomeArchProtocolGuid AND gEfiMonotonicCounterArchProtocolGuid AND gEfiRealTimeClockArchProtocolGuid AND gEfiResetArchProtocolGuid AND gEfiRuntimeArchProtocolGuid AND gEfiSecurityArchProtocolGuid AND gEfiTimerArchProtocolGuid AND gEfiVariableWriteArchProtocolGuid AND gEfiVariableArchProtocolGuid AND gEfiWatchdogTimerArchProtocolGuid)

[UserExtensions.TianoCore."ExtraFiles"]
PcdDxeExtra.uni



#
# The following information is for reference only and not required by the build tools.
#
#  VALID_ARCHITECTURES           = IA32 X64 EBC
#

[BuildOptions.AARCH64]
## @AsBuilt
##   GCC:DEBUG_GCC5_AARCH64_ASLPP_FLAGS = -x c -E -include AutoGen.h
##   GCC:DEBUG_GCC5_AARCH64_ASLDLINK_FLAGS = -Wl,--emit-relocs -nostdlib -Wl,--gc-sections -u $(IMAGE_ENTRY_POINT) -Wl,-e,$(IMAGE_ENTRY_POINT),-Map,$(DEST_DIR_DEBUG)/$(BASE_NAME).map -z common-page-size=0x20 -Wl,--entry,ReferenceAcpiTable -u $(IMAGE_ENTRY_POINT) -Wl,--defsym=PECOFF_HEADER_SIZE=0 -Wl,--script=$(EDK_TOOLS_PATH)/Scripts/GccBase.lds -z common-page-size=0x20
##   GCC:DEBUG_GCC5_AARCH64_GENFW_FLAGS = 
##   GCC:DEBUG_GCC5_AARCH64_OBJCOPY_FLAGS = objcopy not needed for
##   GCC:DEBUG_GCC5_AARCH64_ASM_FLAGS = $(ARCHASM_FLAGS) $(PLATFORM_FLAGS) -c -x assembler -imacros $(DEST_DIR_DEBUG)/AutoGen.h -mlittle-endian
##   GCC:DEBUG_GCC5_AARCH64_CC_FLAGS = $(ARCHCC_FLAGS) $(PLATFORM_FLAGS) -g -fshort-wchar -fno-builtin -fno-strict-aliasing -Wall -Werror -Wno-array-bounds -ffunction-sections -fdata-sections -include AutoGen.h -fno-common -DSTRING_ARRAY_NAME=$(BASE_NAME)Strings -g -Os -fshort-wchar -fno-builtin -fno-strict-aliasing -Wall -Werror -Wno-array-bounds -include AutoGen.h -fno-common -mlittle-endian -fno-short-enums -fverbose-asm -funsigned-char  -ffunction-sections -fdata-sections -Wno-address -fno-asynchronous-unwind-tables -fno-unwind-tables -fno-pic -fno-pie -ffixed-x18 -mcmodel=small -flto -Wno-unused-but-set-variable -Wno-unused-const-variable
##   GCC:DEBUG_GCC5_AARCH64_ASMLINK_FLAGS = /nologo /tiny
##   GCC:DEBUG_GCC5_AARCH64_VFR_FLAGS = -l -n
##   GCC:DEBUG_GCC5_AARCH64_ASLCC_FLAGS = -x c -fno-lto
##   GCC:DEBUG_GCC5_AARCH64_APP_FLAGS = 
##   GCC:DEBUG_GCC5_AARCH64_OPTROM_FLAGS = -e
##   GCC:DEBUG_GCC5_AARCH64_DTC_FLAGS = -H epapr
##   GCC:DEBUG_GCC5_AARCH64_MAKE_FLAGS = -s
##   GCC:DEBUG_GCC5_AARCH64_SYMRENAME_FLAGS = Symbol renaming not needed for
##   GCC:DEBUG_GCC5_AARCH64_RC_FLAGS = -I binary -O elf64-littleaarch64 -B aarch64 --rename-section .data=.hii
##   GCC:DEBUG_GCC5_AARCH64_PP_FLAGS = $(ARCHCC_FLAGS) $(PLATFORM_FLAGS) -E -x assembler-with-cpp -include $(DEST_DIR_DEBUG)/AutoGen.h
##   GCC:DEBUG_GCC5_AARCH64_VFRPP_FLAGS = $(ARCHCC_FLAGS) $(PLATFORM_FLAGS) -x c -E -P -DVFRCOMPILE --include $(DEST_DIR_DEBUG)/$(MODULE_NAME)StrDefs.h
##   GCC:DEBUG_GCC5_AARCH64_DLINK_FLAGS = -Wl,--emit-relocs -nostdlib -Wl,--gc-sections -u $(IMAGE_ENTRY_POINT) -Wl,-e,$(IMAGE_ENTRY_POINT),-Map,$(DEST_DIR_DEBUG)/$(BASE_NAME).map -z common-page-size=0x20 -z common-page-size=0x1000 -flto -Os -L/home/core/edk2/ArmPkg/Library/GccLto -llto-aarch64 -Wl,-plugin-opt=-pass-through=-llto-aarch64 -Wno-lto-type-mismatch
##   GCC:DEBUG_GCC5_AARCH64_PLATFORM_FLAGS = 
##   GCC:DEBUG_GCC5_AARCH64_ASL_FLAGS = 
##   GCC:DEBUG_GCC5_AARCH64_NASMB_FLAGS = -f bin
##   GCC:DEBUG_GCC5_AARCH64_DLINK2_FLAGS = -Wl,--script=$(EDK_TOOLS_PATH)/Scripts/GccBase.lds -Wl,--defsym=PECOFF_HEADER_SIZE=0x228 -Wno-error
##   GCC:DEBUG_GCC5_AARCH64_DTCPP_FLAGS = -E -x assembler-with-cpp -imacros $(DEST_DIR_DEBUG)/AutoGen.h -nostdinc -undef
